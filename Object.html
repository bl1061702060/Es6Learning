<!DOCTYPE html>
<html>

<head>
    <title>对象的拓展</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <script>
        //1. 属性的简洁表示法
        {
            //ES6允许直接写入变量和函数，作为对象的属性和方法
            let foo = 'bar';
            let baz1 = {
                foo
            }; // {foo: "bar"}

            // 等同于
            let baz2 = {
                foo: foo
            };

            //ES6允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。下面是另一个例子。
            function f1(x, y) {
                return {
                    x,
                    y
                };
            }
            // 等同于
            function f2(x, y) {
                return {
                    x: x,
                    y: y
                };
            }
            f1(1, 2); // Object {x: 1, y: 2}
            f2(1, 2); // Object {x: 1, y: 2}

            //除了属性简写，方法也可以简写。
            var o = {
                method() {
                    return "Hello!";
                }
            };

            // 等同于
            var o2 = {
                method: function() {
                    return "Hello!";
                }
            };
            //下面是一个实际的例子。
            var birth = '2000/01/01';
            var Person = {
                name: '张三',
                //等同于birth: birth
                birth,
                // 等同于hello: function ()...
                hello() {
                    console.log('我的名字是', this.name);
                }
            };
            Person.hello();
            //属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。
            var cart = {
                _wheels: 4,
                get wheels() {
                    return this._wheels;
                },
                set wheels(value) {
                    if (value < this._wheels) {
                        throw new Error('数值太小了！');
                    }
                    this._wheels = value;
                }
            }
            cart.wheels = 5;

            //注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。
            let obj = {
                class() {}
            };
            // 等同于
            let obj1 = {
                'class': function() {}
            };
            //上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。

            //如果某个方法的值是一个Generator函数，前面需要加上星号。
            let obj2 = {
                * m() {
                    yield 'hello world';
                }
            };
        }
        //2. 属性名表达式 
        {
            //上面代码的方法一是直接用标识符作为属性名， 方法二是用表达式作为属性名， 这时要将表达式放在方括号之内。
            let obj = {};
            // 方法一
            obj.foo = true;
            // 方法二
            obj['a' + 'bc'] = 123;

            //如果使用字面量方式定义对象（使用大括号），在ES5中只能使用方法一（标识符）定义属性。
            var obj1 = {
                foo: true,
                abc: 123
            };
            //ES6允许字面量定义对象时， 用方法二（ 表达式） 作为对象的属性名， 即把表达式放在方括号内。
            let propKey = 'foo';
            let obj2 = {
                [propKey]: true,
                ['a' + 'bc']: 123
            };

            var lastWord = 'last word';
            var a = {
                'first word': 'hello',
                [lastWord]: 'world'
            };
            a['first word'] // "hello"
            a[lastWord] // "world"
            a['last word'] // "world"

            //表达式还可以用于定义方法名。
            let obj3 = {
                ['h' + 'ello']() {
                    return 'hi';
                },
                ['hello world']() {
                    return 'hello world';
                }
            };
            obj3.hello() // hi

            // 注意，属性名表达式与简洁表示法，不能同时使用，会报错。
            // 报错
            //let foo = 'bar';
            //let baz = {
            //    [foo]
            //};

            // 正确
            let foo1 = 'bar';
            let baz1 = {
                [foo1]: 'abc'
            };
        }
        //3. 方法的name属性
        {
            "use strict";
            //函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。
            var person = {
                sayName() {
                    console.log(this.name);
                },
                get firstName() {
                    return "Nicholas";
                }
            };
            person.sayName.name; // "sayName"
            let firstFuncName = person.firstName.name; // "get firstName" chrome 上得不到值，因为person.firstName 为 “Nicholas” 不是function

            //有两种特殊情况：bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”。
            let funcName = (new Function()).name; // "anonymous"

            var doSomething = function() {
                // ...
            };
            doSomething.bind().name; // "bound doSomething"

            //如果对象的方法是一个Symbol值， 那么name属性返回的是这个Symbol值的描述。
            const key1 = Symbol('description');
            const key2 = Symbol();
            let obj = {
                [key1]() {},
                [key2]() {},
            };
            obj[key1].name // "[description]"
            obj[key2].name // ""
        }
        //4. Object.is()
        {
            //ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。
            //ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。
            Object.is('foo', 'foo'); // true
            Object.is({}, {}); // false
            //不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
            +0 === -0 ;//true
            NaN === NaN; // false

            Object.is(+0, -0); // false
            Object.is(NaN, NaN); // true


        }
    </script>
</body>

</html>