<!DOCTYPE html>
<html>

<head>
    <title></title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <script>
        //1.Prox概述
        {
            //Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。
            //Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。
            var obj = new Proxy({}, {
                get: function(target, key, receiver) {
                    console.log(`getting ${key}!`);
                    return Reflect.get(target, key, receiver);
                },
                set: function(target, key, value, receiver) {
                    console.log(`setting ${key}!`);
                    return Reflect.set(target, key, value, receiver);
                }
            });
            obj.count = 1;
            //  setting count!
            ++obj.count;
            //  getting count!
            //  setting count!
            //  2
            //上面代码说明，Proxy实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。

            //ES6原生提供Proxy构造函数，用来生成Proxy实例。
            //var proxy = new Proxy(target, handler);
            //Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。

            //如果handler没有设置任何拦截， 那就等同于直接通向原对象。
            var target = {};
            var handler = {};
            var proxy = new Proxy(target, handler);
            proxy.a = 'b';
            target.a // "b"

            //一个技巧是将Proxy对象， 设置到object.proxy属性， 从而可以在object对象上调用。
            var object = {
                proxy: new Proxy({}, {
                    get: function(target, property) {
                        return 35;
                    }
                })
            };
            object.proxy.test; //35

            //Proxy实例也可以作为其他对象的原型对象。
            var proxy1 = new Proxy({}, {
                get: function(target, property) {
                    return 35;
                }
            });

            let obj1 = Object.create(proxy1);
            obj.time; // 35

            //上面代码中， proxy对象是obj对象的原型， obj对象本身并没有time属性， 所以根据原型链， 会在proxy对象上读取该属性， 导致被拦截。
        }
        //get() 
        {
            //利用Proxy， 可以将读取属性的操作（ get）， 转变为执行某个函数， 从而实现属性的链式操作。
            var pipe = (function() {
                return function(value) {
                    var funcStack = [];
                    var oproxy = new Proxy({}, {
                        get: function(pipeObject, fnName) {
                            if (fnName === 'get') {
                                return funcStack.reduce(function(val, fn) {
                                    return fn(val);
                                }, value);
                            }
                            funcStack.push(window[fnName]);
                            return oproxy;
                        }
                    });

                    return oproxy;
                }
            }());

            var double = n => n * 2;
            var pow = n => n * n;
            var reverseInt = n => n.toString().split("").reverse().join("") | 0;

            pipe(3).double.pow.reverseInt.get; // 63
            //上面代码设置Proxy以后， 达到了将函数名链式使用的效果。

            //下面的例子则是利用get拦截， 实现一个生成各种DOM节点的通用函数dom。
            const dom = new Proxy({}, {
                get(target, property) {
                    return function(attrs = {}, ...children) {
                        const el = document.createElement(property);
                        for (let prop of Object.keys(attrs)) {
                            el.setAttribute(prop, attrs[prop]);
                        }
                        for (let child of children) {
                            if (typeof child === 'string') {
                                child = document.createTextNode(child);
                            }
                            el.appendChild(child);
                        }
                        return el;
                    }
                }
            });

            const el = dom.div({},
                'Hello, my name is ',
                dom.a({
                    href: '//example.com'
                }, 'Mark'),
                '. I like:',
                dom.ul({},
                    dom.li({}, 'The web'),
                    dom.li({}, 'Food'),
                    dom.li({}, '…actually that\'s it')
                )
            );

            document.body.appendChild(el);
        }

        //set()
        {
            //set方法用来拦截某个属性的赋值操作。
            //假定Person对象有一个age属性， 该属性应该是一个不大于200的整数， 那么可以使用Proxy保证age的属性值符合要求。
            let validator = {
                set: function(obj, prop, value) {
                    if (prop === 'age') {
                        if (!Number.isInteger(value)) {
                            throw new TypeError('The age is not an integer');
                        }
                        if (value > 200) {
                            throw new RangeError('The age seems invalid');
                        }
                    }

                    // 对于age以外的属性，直接保存
                    obj[prop] = value;
                }
            };

            let person = new Proxy({}, validator);
            person.age = 100;
            person.age; // 100
            //person.age = 'young'; // 报错
            //person.age = 300; // 报错

            //结合get和set方法，就可以做到防止这些内部属性被外部读写。
            var handler = {
                get(target, key) {
                    invariant(key, 'get');
                    return target[key];
                },
                set(target, key, value) {
                    invariant(key, 'set');
                    return true;
                }
            };

            function invariant(key, action) {
                if (key[0] === '_') {
                    throw new Error(`Invalid attempt to ${action} private "${key}" property`);
                }
            }
            var target = {};
            var proxy = new Proxy(target, handler);
            //proxy._prop;
            // Error: Invalid attempt to get private "_prop" property
            //k07proxy._prop = 'c';
            // Error: Invalid attempt to set private "_prop" property
        }
        //
        {
            //apply()
            //apply方法拦截函数的调用、 call和apply操作。
            // var handler = {
            //     apply(target, ctx, args) {
            //         return Reflect.apply(...arguments);
            //     }
            // };

            //apply方法可以接受三个参数， 分别是目标对象、 目标对象的上下文对象（ this） 和目标对象的参数数组。
            var target = function() {
                return 'I am the target';
            };
            var handler = {
                apply: function() {
                    return 'I am the proxy';
                }
            };
            var p = new Proxy(target, handler);
            p(); // "I am the proxy"

            //下面是另外一个例子。
            var twice = {
                apply(target, ctx, args) {
                    return Reflect.apply(...arguments) * 2;
                }
            };

            function sum(left, right) {
                return left + right;
            };
            var proxy2 = new Proxy(sum, twice);
            proxy2(1, 2); // 6
            proxy2.call(null, 5, 6); // 22
            proxy2.apply(null, [7, 8]); // 30


            //上面代码中， 每当执行proxy函数（ 直接调用或call和apply调用）， 就会被apply方法拦截。

            //另外， 直接调用Reflect.apply方法， 也会被拦截。
            Reflect.apply(proxy2, null, [9, 10]); // 38
        }

        //has()
        {
            //has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符
            var handler = {
                has(target, key) {
                    if (key[0] === '_') {
                        return false;
                    }
                    return key in target;
                }
            };
            var target = {
                _prop: 'foo',
                prop: 'foo'
            };
            var proxy = new Proxy(target, handler);
            '_prop' in proxy; // false

            //obj对象禁止扩展，结果使用has拦截就会报错。
            //虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效
        }
    </script>
</body>

</html>