<!DOCTYPE html>
<html>

<head>
    <title>函数的扩展</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <div></div>
    <div></div>
    <div></div>
    <script>
        //1. 函数参数的默认值
        {
            function log(x, y) {
                y = y || 'World';
                console.log(x, y);
            }
            log('Hello'); // Hello World
            log('Hello', 'China'); // Hello China
            log('Hello', ''); // Hello World

            //ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。
            function log1(x, y = 'World') {
                console.log(x, y);
            }
            log1('Hello'); // Hello World
            log1('Hello', 'China'); // Hello China
            log1('Hello', ''); // Hello
            //参数变量是默认声明的，所以不能用let或const再次声明。
            function foo(x = 5) {
                //    let x = 1; // error
                //   const x = 2; // error
            }
            //参数默认值可以与解构赋值的默认值，结合起来使用。
            function foo2({
                x,
                y = 5
            }) {
                console.log(x, y);
            }

            foo2({}); // undefined, 5
            foo2({
                x: 1
            }); // 1, 5
            foo2({
                x: 1,
                y: 2
            }); // 1, 2
            //foo2() // TypeError: Cannot read property 'x' of undefined
        }
        //参数默认值的位置
        {
            //通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。
            // 例一
            function f(x = 1, y) {
                return [x, y];
            }

            f(); // [1, undefined]
            f(2); // [2, undefined])
            //f(, 1); // 报错
            f(undefined, 1); // [1, 1]

            // 例二
            function f1(x, y = 5, z) {
                return [x, y, z];
            }

            f1(); // [undefined, 5, undefined]
            f1(1); // [1, 5, undefined]
            //f1(1, , 2); // 报错
            f1(1, undefined, 2); // [1, 5, 2]

            // 例三
            function f2(x, y, z = 5) {
                return [x, y, z];
            }

            f2(); // [undefined, undefined, 5]
            f2(1); // [1, undefined, 5]
            f2(1, 2); // [1, 2, 5]
            f2(1, undefined, 2); // [1, undefined, 2]

            //如果传入undefined，将触发该参数等于默认值，null则没有这个效果。
            function f3(x = 5, y = 6) {
                console.log(x, y);
            }
            f3(undefined, null); // 5 null

            //指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
            (function(a) {}).length; // 1
            (function(a = 5) {}).length; // 0
            (function(a, b, c = 5) {}).length; // 2
            (function(...args) {}).length; // 0
            //如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
            (function(a = 0, b, c) {}).length; // 0
            (function(a, b = 1, c) {}).length; // 1
        }
        //作用域
        {
            //一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。
            let x = 1;

            function f(x, y = x) {
                console.log(y);
            }
            f(2); // 2

            //如果调用时，函数作用域内部的变量x没有生成，结果就会不一样。
            let x1 = 1;

            function f1(y1 = x1) {
                let x1 = 2;
                console.log(y1);
            }
            f1(); // 1
            //上面代码中，函数调用时，y的默认值变量x尚未在函数内部生成，所以x指向全局变量。

            //如果此时，全局变量x不存在，就会报错。
            function f2(y2 = x2) {
                let x2 = 2;
                console.log(y2);
            }
            //f2(); //x2 is not defined

            //如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。
            let foo = 'outer';

            function bar(func = x => foo) {
                let foo = 'inner';
                console.log(func()); // outer
            }
            bar();
            //上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。这个匿名函数声明时，bar函数的作用域还没有形成，所以匿名函数里面的foo指向外层作用域的foo，输出outer。
            let x3 = 1;

            function foo1(x3, y3 = function() {
                console.log('匿名函数的x：' + x3);
                x3 = 2;
            }) {
                var x3 = 3;
                y3();
                console.log(x3);
            }
            foo1(); // 3
        }
        //2. rest参数
        {
            //ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
            function add(...values) {
                let sum = 0;

                for (var val of values) {
                    sum += val;
                }

                return sum;
            }

            add(2, 5, 3); // 10
            // arguments变量的写法
            function sortNumbers() {
                return Array.prototype.slice.call(arguments).sort();
            }
            const sortNumbers2 = (...numbers) => numbers.sort();
            sortNumbers(3, 4, 5, 6, 1, 7);
            sortNumbers2(3, 4, 5, 6, 1, 7);
            //注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
            // 报错
            //function f(a, ...b, c) {
            // ...
            //}//Uncaught SyntaxError: Rest parameter must be last formal parameter
            //函数的length属性，不包括rest参数。
            (function(a) {}).length; // 1
            (function(...a) {}).length; // 0
            (function(a, ...b) {}).length; // 1
        }
        //3. 扩展运算符 
        {
            //扩展运算符（ spread） 是三个点（...）。它好比rest参数的逆运算， 将一个数组转为用逗号分隔的参数序列。
            console.log(...[1, 2, 3]); // 1 2 3
            console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5
            console.log(...document.querySelectorAll('div')); // 1 2 3 4 5
            [...document.querySelectorAll('div')]; // [<div>, <div>, <div>]

            //替代数组的apply方法
            //由于扩展运算符可以展开数组， 所以不再需要apply方法， 将数组转为函数的参数了。
            // ES5的写法
            function f(x, y, z) {
                // ...
            }
            var args = [0, 1, 2, 3];
            f.apply(null, args);

            // ES6的写法
            function f1(x, y, z) {
                // ...
            }
            var args = [0, 1, 2, 3];
            f1(...args);

            //下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。
            // ES5的写法
            Math.max.apply(null, [14, 3, 77]);
            // ES6的写法
            Math.max(...[14, 3, 77]);
            // 等同于
            Math.max(14, 3, 77);

            //上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。
            //另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。
            // ES5的写法
            let arr1 = [0, 1, 2];
            let arr2 = [3, 4, 5];
            Array.prototype.push.apply(arr1, arr2);
            // ES6的写法
            arr1.push(...arr2);
            // ES5
            new(Date.bind.apply(Date, [null, 2015, 1, 1]));
            // ES6
            new Date(...[2015, 1, 1]);

            //扩展运算符的应用 
            //（1）合并数组
            //扩展运算符提供了数组合并的新写法。
            // ES5
            [1, 2].concat([3, 4]);
            // ES6
            [1, 2, ...[3, 4]];

            let arr3 = ['a', 'b'];
            let arr4 = ['c'];
            let arr5 = ['d', 'e'];

            // ES5的合并数组
            arr3.concat(arr4, arr5);
            // [ 'a', 'b', 'c', 'd', 'e' ]

            // ES6的合并数组
            [...arr3, ...arr4, ...arr5];
            // [ 'a', 'b', 'c', 'd', 'e' ]

            //（2）与解构赋值结合
            //扩展运算符可以与解构赋值结合起来，用于生成数组。
            let list = [1, 2, 3, 4, 5];
            // ES5
            let a = list[0],
                other = list.slice(1);
            // ES6
            [a, ...other] = list;
            //下面是另外一些例子。
            const [first0, ...rest0] = [1, 2, 3, 4, 5];
            first0; // 1
            rest0; // [2, 3, 4, 5]

            const [first1, ...rest1] = [];
            first1; // undefined
            rest1; // []:

            const [first2, ...rest2] = ["foo"];
            first2; // "foo"
            rest2; // []

            //如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
            const [first3, middle3, ...last3] = [1, 2, 3, 4, 5];
            //const [...butLast, last] = [1, 2, 3, 4, 5];
            // 报错 Uncaught SyntaxError: Rest element must be last element in array
            //const [first, ...middle, last] = [1, 2, 3, 4, 5];
            // 报错

            //（3）函数的返回值
            //JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。
            //var dateFields = readDateFields(database);
            //var d = new Date(...dateFields);

            //（4）字符串

            //扩展运算符还可以将字符串转为真正的数组。
            [...
                'hello'
            ];
            // [ "h", "e", "l", "l", "o" ]

            //上面的写法，有一个重要的好处，那就是能够正确识别32位的Unicode字符。
            'x\uD83D\uDE80y'.length; // 4
            [...
                'x\uD83D\uDE80y'
            ].length; // 3
            //凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。
            let str = 'x\uD83D\uDE80y';
            str.split('').reverse().join('');
            // 'y\uDE80\uD83Dx'
            [...str].reverse().join('');
            // 'y\uD83D\uDE80x'

            //（5） 实现了Iterator接口的对象
            //任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。
            var nodeList = document.querySelectorAll('div');
            var array = [...nodeList];

            //上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator接口。

            //对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。
            let arrayLike = {
                '0': 'a',
                '1': 'b',
                '2': 'c',
                length: 3
            };
            // TypeError: Cannot spread non-iterable object.
            //let arr = [...arrayLike];

            //（6）Map和Set结构，Generator函数

            //扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。
            let map = new Map([
                [1, 'one'],
                [2, 'two'],
                [3, 'three'],
            ]);
            let arr = [...map.keys()]; // [1, 2, 3]

            //Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。
            var go = function*() {
                yield 1;
                yield 2;
                yield 3;
            };
            [...go()] // [1, 2, 3]
            //上面代码中，变量go是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。
        }
        //4. 严格模式
        {
            //从ES5开始，函数内部可以设定为严格模式。
            function doSomething(a, b) {
                'use strict';
                // code
            }
            //《ECMAScript 2016 标准》 做了一点修改， 规定只要函数参数使用了默认值、 解构赋值、 或者扩展运算符， 那么函数内部就不能显式设定为严格模式， 否则会报错。
            // 报错 Uncaught SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list
            //function doSomething(a, b = a) {
            //    'use strict';
            // code
            //}
            // 报错
            //const doSomething1 = function({a,b}) {
            //   'use strict';
            // code
            //};
            // 报错
            //const doSomething2 = (...a) => {
            //    'use strict';
            // code
            //};
            //const obj = {
            // 报错
            //    doSomething({a, b}) {
            //        'use strict';
            // code
            //    }
            //};
            //两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。
            'use strict';

            function doSomething3(a, b = a) {
                // code
            }

            //第二种是把函数包在一个无参数的立即执行函数里面。
            const doSomething4 = (function() {
                'use strict';
                return function(value = 42) {
                    return value;
                };
            }());
        }
        //5. name属性
        {
            //函数的name属性，返回该函数的函数名。
            function foo() {}
            foo.name; // "foo"

            //这个属性早就被浏览器广泛支持，但是直到ES6，才将其写入了标准。
            //需要注意的是，ES6对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5的name属性，会返回空字符串，而ES6的name属性会返回实际的函数名。
            let func1 = function() {};
            // ES5
            func1.name; // ""
            // ES6
            func1.name; // "func1"
            //如果将一个具名函数赋值给一个变量，则ES5和ES6的name属性都返回这个具名函数原本的名字。
            const bar = function baz() {};
            // ES5
            bar.name; // "baz"
            // ES6
            bar.name; // "baz"
            //Function构造函数返回的函数实例，name属性的值为“anonymous”。
            let funcName = (new Function).name; // "anonymous" 匿名的

            //bind返回的函数，name属性值会加上“bound ”前缀。
            foo.bind({}).name; // "bound foo"
            (function() {}).bind({}).name; // "bound "
        }
        //6. 箭头函数 
        {
            //基本用法
            //ES6允许使用“ 箭头”（ => ）定义函数。
            let f = v => v;
            //上面的箭头函数等同于：
            let f1 = function(v) {
                return v;
            };
            //如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
            let sum = (num1, num2) => {
                return num1 + num2;
            };
            //由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。
            let getTempItem = id => ({
                id: id,
                name: "Temp"
            });
            //箭头函数可以与变量解构结合使用。
            const full = ({
                first,
                last
            }) => first + ' ' + last;
            // 等同于
            const full1 = function full1(person) {
                return person.first + ' ' + person.last;
            };
            //箭头函数使得表达更加简洁。
            const isEven = n => n % 2 == 0;
            const square = n => n * n;
            //箭头函数的一个用处是简化回调函数。
            // 正常函数写法
            [1, 2, 3].map(function(x) {
                return x * x;
            });
            // 箭头函数写法
            [1, 2, 3].map(x => x * x);
            //另一个例子是
            // 正常函数写法
            let result1 = [3, 2, 4, 1].sort(function(a, b) {
                return a - b;
            });
            // 箭头函数写法
            let result2 = [3, 2, 4, 1].sort((a, b) => a - b);

            //下面是rest参数与箭头函数结合的例子。
            const numbers = (...nums) => nums;
            numbers(1, 2, 3, 4, 5); // [1,2,3,4,5]
            const headAndTail = (head, ...tail) => [head, tail];
            headAndTail(1, 2, 3, 4, 5); // [1,[2,3,4,5]]

            //箭头函数有几个使用注意点。
            //（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
            //（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
            //（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
            //（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。
            //上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。
            let foo = function foo() {
                setTimeout(() => {
                    console.log('id:', this.id);
                }, 100);
            }
            var id = 21;
            foo.call({
                id: 42
            });
            // id: 42
            let Timer = function Timer() {
                this.s1 = 0;
                this.s2 = 0;
                // 箭头函数
                setInterval(() => this.s1++, 1000);
                // 普通函数
                setInterval(function() {
                    this.s2++;
                }, 1000);
            }
            let timer = new Timer();
            setTimeout(() => console.log('s1: ', timer.s1), 3100);
            setTimeout(() => console.log('s2: ', timer.s2), 3100);
            // s1: 3
            // s2: 0
            //箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。
            let handler = {
                id: '123456',
                init: function() {
                    document.addEventListener('click', event => this.doSomething(event.type), false);
                },
                doSomething: function(type) {
                    console.log('Handling ' + type + ' for ' + this.id);
                }
            };
            handler.init();
            //this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部//的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

            //所以，箭头函数转成ES5的代码如下。
            // ES6
            let foo1 = function foo1() {
                setTimeout(() => {
                    console.log('id:', this.id);
                }, 100);
            };
            foo1();
            // ES5
            let foo2 = function foo2() {
                var _this = this;
                setTimeout(function() {
                    console.log('id:', _this.id);
                }, 100);
            };
            foo2();

            //请问下面的代码之中有几个this？
            function foo3() {
                return () => {
                    return () => {
                        return () => {
                            console.log('id:', this.id);
                        };
                    };
                };
            }
            let f2 = foo3.call({
                id: 1
            });
            let t1 = f2.call({
                id: 2
            })()(); // id: 1
            let t2 = f2().call({
                id: 3
            })(); // id: 1
            let t3 = f2()().call({
                id: 4
            }); // id: 1

            //除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。
            let foo4 = function foo4() {
                setTimeout(() => {
                    console.log('args:', arguments);
                }, 100);
            }
            foo4(2, 4, 6, 8);
            // args: [2, 4, 6, 8]
            //上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。

            //另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。
            (function() {
                return [(() => console.log(this.x)).bind({
                    x: 'inner'
                })()]
            }).call({
                x: 'outer'
            });
            // ['outer']
            //上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。

            //嵌套的箭头函数
            //箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。
            function insert(value) {
                return {
                    into: function(array) {
                        return {
                            after: function(afterValue) {
                                array.splice(array.indexOf(afterValue) + 1, 0, value);
                                return array;
                            }
                        };
                    }
                };
            }

            insert(2).into([1, 3]).after(1); //[1, 2, 3]

            //上面这个函数， 可以使用箭头函数改写。
            let insert1 = (value) => ({
                into: (array) => ({
                    after: (afterValue) => {
                        array.splice(array.indexOf(afterValue) + 1, 0, value);
                        return array;
                    }
                })
            });
            insert1(2).into([1, 3]).after(1); //[1, 2, 3]

            //下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。
            const pipeline = (...funcs) => val => funcs.reduce((a, b) => b(a), val);

            const plus = a => a + 1;
            const mult = a => a * 2;
            const addThenMult = pipeline(plus, mult);
            addThenMult(5); // 12

            //如果觉得上面的写法可读性比较差，也可以采用下面的写法。
            const plus1 = a => a + 1;
            const mult1 = a => a * 2;
            mult1(plus1(5));
            //箭头函数还有一个功能，就是可以很方便地改写λ演算。
            // λ演算的写法
            //fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)));

            // ES6的写法
            var fix = f => (x => f(v => x(x)(v)))(x => f(v => x(x)(v)));
            fix(x => x * x)(3)


        }
    </script>
</body>

</html>