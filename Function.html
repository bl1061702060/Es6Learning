<!DOCTYPE html>
<html>

<head>
    <title>函数的扩展</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <div></div>
    <div></div>
    <div></div>
    <script>
        //1. 函数参数的默认值
        {
            function log(x, y) {
                y = y || 'World';
                console.log(x, y);
            }
            log('Hello'); // Hello World
            log('Hello', 'China'); // Hello China
            log('Hello', ''); // Hello World

            //ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。
            function log1(x, y = 'World') {
                console.log(x, y);
            }
            log1('Hello'); // Hello World
            log1('Hello', 'China'); // Hello China
            log1('Hello', ''); // Hello
            //参数变量是默认声明的，所以不能用let或const再次声明。
            function foo(x = 5) {
                //    let x = 1; // error
                //   const x = 2; // error
            }
            //参数默认值可以与解构赋值的默认值，结合起来使用。
            function foo2({
                x,
                y = 5
            }) {
                console.log(x, y);
            }

            foo2({}); // undefined, 5
            foo2({
                x: 1
            }); // 1, 5
            foo2({
                x: 1,
                y: 2
            }); // 1, 2
            //foo2() // TypeError: Cannot read property 'x' of undefined
        }
        //参数默认值的位置
        {
            //通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。
            // 例一
            function f(x = 1, y) {
                return [x, y];
            }

            f(); // [1, undefined]
            f(2); // [2, undefined])
            //f(, 1); // 报错
            f(undefined, 1); // [1, 1]

            // 例二
            function f1(x, y = 5, z) {
                return [x, y, z];
            }

            f1(); // [undefined, 5, undefined]
            f1(1); // [1, 5, undefined]
            //f1(1, , 2); // 报错
            f1(1, undefined, 2); // [1, 5, 2]

            // 例三
            function f2(x, y, z = 5) {
                return [x, y, z];
            }

            f2(); // [undefined, undefined, 5]
            f2(1); // [1, undefined, 5]
            f2(1, 2); // [1, 2, 5]
            f2(1, undefined, 2); // [1, undefined, 2]

            //如果传入undefined，将触发该参数等于默认值，null则没有这个效果。
            function f3(x = 5, y = 6) {
                console.log(x, y);
            }
            f3(undefined, null); // 5 null

            //指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
            (function(a) {}).length; // 1
            (function(a = 5) {}).length; // 0
            (function(a, b, c = 5) {}).length; // 2
            (function(...args) {}).length; // 0
            //如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。
            (function(a = 0, b, c) {}).length; // 0
            (function(a, b = 1, c) {}).length; // 1
        }
        //作用域
        {
            //一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。
            let x = 1;

            function f(x, y = x) {
                console.log(y);
            }
            f(2); // 2

            //如果调用时，函数作用域内部的变量x没有生成，结果就会不一样。
            let x1 = 1;

            function f1(y1 = x1) {
                let x1 = 2;
                console.log(y1);
            }
            f1(); // 1
            //上面代码中，函数调用时，y的默认值变量x尚未在函数内部生成，所以x指向全局变量。

            //如果此时，全局变量x不存在，就会报错。
            function f2(y2 = x2) {
                let x2 = 2;
                console.log(y2);
            }
            //f2(); //x2 is not defined

            //如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。
            let foo = 'outer';

            function bar(func = x => foo) {
                let foo = 'inner';
                console.log(func()); // outer
            }
            bar();
            //上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。这个匿名函数声明时，bar函数的作用域还没有形成，所以匿名函数里面的foo指向外层作用域的foo，输出outer。
            let x3 = 1;

            function foo1(x3, y3 = function() {
                console.log('匿名函数的x：' + x3);
                x3 = 2;
            }) {
                var x3 = 3;
                y3();
                console.log(x3);
            }
            foo1(); // 3
        }
        //2. rest参数
        {
            //ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。
            function add(...values) {
                let sum = 0;

                for (var val of values) {
                    sum += val;
                }

                return sum;
            }

            add(2, 5, 3); // 10
            // arguments变量的写法
            function sortNumbers() {
                return Array.prototype.slice.call(arguments).sort();
            }
            const sortNumbers2 = (...numbers) => numbers.sort();
            sortNumbers(3, 4, 5, 6, 1, 7);
            sortNumbers2(3, 4, 5, 6, 1, 7);
            //注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
            // 报错
            //function f(a, ...b, c) {
            // ...
            //}//Uncaught SyntaxError: Rest parameter must be last formal parameter
            //函数的length属性，不包括rest参数。
            (function(a) {}).length; // 1
            (function(...a) {}).length; // 0
            (function(a, ...b) {}).length; // 1
        }
        //3. 扩展运算符 
        {
            //扩展运算符（ spread） 是三个点（...）。它好比rest参数的逆运算， 将一个数组转为用逗号分隔的参数序列。
            console.log(...[1, 2, 3]); // 1 2 3
            console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5
            console.log(...document.querySelectorAll('div')); // 1 2 3 4 5
            [...document.querySelectorAll('div')]; // [<div>, <div>, <div>]

            //替代数组的apply方法
            //由于扩展运算符可以展开数组， 所以不再需要apply方法， 将数组转为函数的参数了。
            // ES5的写法
            function f(x, y, z) {
                // ...
            }
            var args = [0, 1, 2, 3];
            f.apply(null, args);

            // ES6的写法
            function f1(x, y, z) {
                // ...
            }
            var args = [0, 1, 2, 3];
            f1(...args);
            
            //下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。
            // ES5的写法
            Math.max.apply(null, [14, 3, 77]);
            // ES6的写法
            Math.max(...[14, 3, 77]);
            // 等同于
            Math.max(14, 3, 77);

            //上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。
            //另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。
            // ES5的写法
            var arr1 = [0, 1, 2];
            var arr2 = [3, 4, 5];
            Array.prototype.push.apply(arr1, arr2);
            // ES6的写法
            var arr1 = [0, 1, 2];
            var arr2 = [3, 4, 5];
            arr1.push(...arr2);
        }
    </script>
</body>

</html>